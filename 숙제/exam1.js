/*
[1] 국내 최대 규모의 프로그래밍 대회에서 경기대 팀은 S대와 결승전에서 맞붙게 되었다.
각 팀은 N명의 프로그래머들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전하여 1:1로 경기를 벌여 승패를 결정하고,
최종적으로 더 많은 승리를 가져온 팀이 우승하게 된다. 각 팀은 결승전 전날, 주최측에 선수들의 출전 순서를 알려주어야 한다.
결승전 이틀 전, 경기대 팀 감독은 첩보를 통해 상대 S대 팀의 출전 순서를 알아내는 데 성공하였다.
문제를 간단하게 하기 위해 1:1 승부에서는 프로그래밍 실력이 높은 선수가 승리하고, 만약에 실력이 동일할 경우에는 경기대 팀이 진다고 가정한다.
경기대 팀의 팀원들의 실력은 배열 K에 K[1], K[2], ..., K[N]의 양의 실수 값으로 주어지며,
S대 팀의 팀원들의 실력은 배열 S에 S[1], S[2], ..., S[N]의 양의 실수 값으로 주어진다. S대 팀원들의 출전 순서는 배열 S의 인덱스 순서와 같다고 가정한다.
이때 우리 경기대 팀이 출전 순서를 최선의 방법으로 정할 경우에 얻을 수 있는 승리의 최대 횟수는 얼마일까?
입력으로 배열 K[1..n]과 S[1..n]이 주어질 때 경기대 팀의 최대 승리 횟수를 출력하는 알고리즘을 기술하고 분석하시오.

(힌트) 이 문제는 greedy algorithm으로 해결할 수 있는 문제이다. 알고리즘을 기술하기 전에 greedy choice의 기준에 대해 설명하고
그것이 왜 옳은 방법인지 증명하거나 설명해야 한다.
*/

const solution = (K, S) => {
  let wins = 0;
  //K배열 내림차순 정렬 머지소트 가정 O(nlogn)
  K.sort((a, b) => b - a);

  // S값 순회 O(n)
  S.forEach((e) => {
    //경기대 중에 가장 실력이 높은 사람보다 S대 실력이 같거나 더 높다면?
    if (K[0] <= e) {
      //경기대에서 실력이 가장 낮은 선수 출전!
      K.pop();
    } else {
      // 만약 이길 수 있는 상대라면?
      K.splice(
        K.findIndex((Ke) => Ke < e),
        1
      );
      //이길 수 있는 사람 중 가장 낮은 사람을 찾아서 출전시킴 O(n)
      wins++;
    }
  });

  return wins;
};
console.log(solution([1, 2, 3, 4, 5], [5, 3, 4, 1, 2]));
